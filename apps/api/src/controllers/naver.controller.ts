import {
  Controller,
  Get,
  Post,
  Schema,
} from "@/decorators/controller.decorator";
import { crawlService, comparisonService } from "@/services";
import { NaverShoppingAPI } from "@/external/apis/naver-shopping-api";
import { CrawlService } from "@/services/crawl.service";
import type { ShoppingInsightsParams } from "@/types/api/naver-shopping.types";
import { FastifyRequest, FastifyReply } from "fastify";

@Controller("/naver")
export class NaverController {
  private naverAPI: NaverShoppingAPI;

  constructor() {
    this.naverAPI = new NaverShoppingAPI();
  }

  @Post("/crawl/reviews")
  @Schema({
    description: "Crawl product reviews from Smart Store",
    tags: ["products"],
    security: [{ bearerAuth: [] }],
    required: ["url"],
    body: {
      type: "object",
      properties: {
        url: { type: "string", format: "uri" },
        sort: {
          type: "string",
          enum: ["ranking", "latest", "high-rating", "low-rating"],
          default: "latest",
        },
        maxPages: {
          type: "number",
          minimum: 1,
          maximum: 100,
          default: 5,
        },
      },
    },
  })
  async crawlReviews(
    request: FastifyRequest<{
      Body: {
        url: string;
        sort?: "ranking" | "latest" | "high-rating" | "low-rating";
        maxPages?: number;
      };
    }>,
    reply: FastifyReply
  ) {
    const { url, sort = "latest", maxPages = 5 } = request.body;

    // SSE Ìó§Îçî ÏÑ§Ï†ï
    reply.raw.setHeader("Content-Type", "text/event-stream");
    reply.raw.setHeader("Cache-Control", "no-cache");
    reply.raw.setHeader("Connection", "keep-alive");
    reply.raw.setHeader("Access-Control-Allow-Origin", "*");
    reply.raw.setHeader("Access-Control-Allow-Headers", "Cache-Control");

    // Ï¥àÍ∏∞ Ïó∞Í≤∞ Î©îÏãúÏßÄ Ï¶âÏãú Ï†ÑÏÜ°
    const initialData = JSON.stringify({
      totalReviews: 0,
      crawledReviews: 0,
      currentPage: 0,
      estimatedTotalPages: maxPages,
      elapsedTime: 0,
      status: "initializing",
      message: "ÌÅ¨Î°§ÎßÅÏùÑ ÏãúÏûëÌï©ÎãàÎã§...",
    });
    reply.raw.write(`data: ${initialData}\n\n`);

    // ÏßÑÌñâ ÏÉÅÌô© ÏΩúÎ∞± Ìï®Ïàò
    const onProgress = (progress: {
      currentPage: number;
      totalPages: number;
      itemsFound: number;
      itemsCrawled: number;
      message?: string;
    }) => {
      console.log("üìä SSE ÏßÑÌñâ ÏÉÅÌô© Ï†ÑÏÜ°:", progress);
      // Map the service progress format to the expected SSE format
      const sseData = {
        totalReviews: progress.itemsFound,
        crawledReviews: progress.itemsCrawled,
        currentPage: progress.currentPage,
        estimatedTotalPages: progress.totalPages,
        elapsedTime: Date.now(),
        status: "crawling",
        message: progress.message || "ÌÅ¨Î°§ÎßÅ Ï§ë...",
      };
      const data = JSON.stringify(sseData);
      reply.raw.write(`data: ${data}\n\n`);
    };

    try {
      const result = await crawlService.crawlSmartStore(
        url,
        {
          maxPages,
          sort: sort as any,
        },
        {
          onProgress: onProgress,
          onItem: (item) => {
            // Í∞úÎ≥Ñ ÏïÑÏù¥ÌÖúÏùÑ SSEÎ°ú Ï†ÑÏÜ°ÌïòÏßÄ ÏïäÍ≥† onProgressÏóêÏÑú Ï≤òÎ¶¨
          },
          onError: (error) => {
            console.error("ÌÅ¨Î°§ÎßÅ ÏóêÎü¨:", error);
            onProgress({
              currentPage: 0,
              totalPages: maxPages,
              itemsFound: 0,
              itemsCrawled: 0,
              message: error.message,
            });
          },
        }
      );

      // ÏµúÏ¢Ö ÏôÑÎ£å Î©îÏãúÏßÄ
      const finalData = JSON.stringify({
        totalReviews: result.length,
        crawledReviews: result.length,
        currentPage: maxPages,
        estimatedTotalPages: maxPages,
        elapsedTime: Date.now(),
        isComplete: true,
        reviews: result.slice(0, 100), // Ï≤òÏùå 100Í∞úÎßå Ï†ÑÏÜ°
        message: `ÌÅ¨Î°§ÎßÅ ÏôÑÎ£å! Ï¥ù ${result.length}Í∞úÏùò Î¶¨Î∑∞Î•º ÏàòÏßëÌñàÏäµÎãàÎã§.`,
      });
      reply.raw.write(`data: ${finalData}\\n\\n`);
    } catch (error) {
      const errorData = JSON.stringify({
        error: error instanceof Error ? error.message : "Unknown error",
        isComplete: true,
      });
      reply.raw.write(`data: ${errorData}\n\n`);
    } finally {
      reply.raw.end();
    }
  }

  @Post("/blog/categories")
  @Schema({
    description: "Get Naver blog categories",
    tags: ["blog"],
    security: [{ bearerAuth: [] }],
    body: {
      type: "object",
      properties: {
        blogId: { type: "string", minLength: 2, maxLength: 50 },
      },
      required: ["blogId"],
    },
  })
  async getBlogCategories(
    request: FastifyRequest<{
      Body: { blogId: string };
    }>
  ) {
    const { blogId } = request.body;

    try {
      const crawlService = new CrawlService();
      const categories = await crawlService.getNaverBlogCategories(blogId);

      return {
        blogId,
        categories,
        totalCategories: categories.length,
      };
    } catch (error) {
      throw new Error(
        error instanceof Error
          ? error.message
          : "Î∏îÎ°úÍ∑∏ Ïπ¥ÌÖåÍ≥†Î¶¨ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
      );
    }
  }

  @Post("/crawl/blog")
  @Schema({
    description: "Crawl Naver blog posts",
    tags: ["blog"],
    security: [{ bearerAuth: [] }],
    body: {
      type: "object",
      properties: {
        url: { type: "string", format: "uri" },
        mode: {
          type: "string",
          enum: ["single", "category", "blog"],
          default: "single",
        },
        maxPages: {
          type: "number",
          minimum: 1,
          maximum: 50,
          default: 5,
        },
        maxItems: {
          type: "number",
          minimum: 1,
          maximum: 1000,
          default: 100,
        },
        blogId: { type: "string" },
        selectedCategories: {
          type: "array",
          items: { type: "number" },
        },
      },
      required: ["url"],
    },
  })
  async crawlBlog(
    request: FastifyRequest<{
      Body: {
        url: string;
        mode?: "single" | "category" | "blog";
        maxPages?: number;
        maxItems?: number;
        blogId?: string;
        selectedCategories?: number[];
      };
    }>,
    reply: FastifyReply
  ) {
    const {
      url,
      mode = "single",
      maxPages = 5,
      maxItems = 100,
      blogId,
      selectedCategories,
    } = request.body;

    // SSE Ìó§Îçî ÏÑ§Ï†ï
    reply.raw.setHeader("Content-Type", "text/event-stream");
    reply.raw.setHeader("Cache-Control", "no-cache");
    reply.raw.setHeader("Connection", "keep-alive");
    reply.raw.setHeader("Access-Control-Allow-Origin", "*");
    reply.raw.setHeader("Access-Control-Allow-Headers", "Cache-Control");

    // Ï¥àÍ∏∞ Ïó∞Í≤∞ Î©îÏãúÏßÄ
    const initialData = JSON.stringify({
      type: "progress",
      progress: {
        currentPage: 0,
        totalPages: mode === "single" ? 1 : maxPages,
        itemsFound: 0,
        itemsCrawled: 0,
        message: "ÎÑ§Ïù¥Î≤Ñ Î∏îÎ°úÍ∑∏ ÌÅ¨Î°§ÎßÅÏùÑ ÏãúÏûëÌï©ÎãàÎã§...",
      },
    });
    reply.raw.write(`data: ${initialData}\n\n`);

    try {
      const crawlService = new CrawlService();

      // Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ†ÌÉù Î™®ÎìúÏùº Í≤ΩÏö∞ Ïó¨Îü¨ Ïπ¥ÌÖåÍ≥†Î¶¨ Ï≤òÎ¶¨
      if (
        mode === "category" &&
        selectedCategories &&
        selectedCategories.length > 1
      ) {
        const allResults: any[] = [];

        for (let i = 0; i < selectedCategories.length; i++) {
          const categoryNo = selectedCategories[i];
          const categoryUrl = `https://blog.naver.com/PostList.naver?blogId=${blogId}&categoryNo=${categoryNo}`;

          try {
            const results = await crawlService.crawlNaverBlog(
              categoryUrl,
              {
                maxPages: Math.ceil(maxPages / selectedCategories.length),
                maxItems: Math.ceil(maxItems / selectedCategories.length),
              },
              {
                onProgress: (progress) => {
                  const data = JSON.stringify({
                    type: "progress",
                    progress: {
                      ...progress,
                      message: `Ïπ¥ÌÖåÍ≥†Î¶¨ ${i + 1}/${selectedCategories.length} ÌÅ¨Î°§ÎßÅ Ï§ë... (${progress.message})`,
                    },
                  });
                  reply.raw.write(`data: ${data}\n\n`);
                },
                onItem: (item) => {
                  const data = JSON.stringify({
                    type: "item",
                    item: {
                      title: item.title,
                      content: item.content,
                      url: item.url,
                      author: item.siteSpecificData?.author,
                      publishDate: item.siteSpecificData?.publishDate,
                      viewCount: item.siteSpecificData?.viewCount,
                      commentCount: item.siteSpecificData?.commentCount,
                      tags: item.siteSpecificData?.tags,
                      category: item.siteSpecificData?.category,
                      thumbnailUrl: item.siteSpecificData?.thumbnailUrl,
                    },
                  });
                  reply.raw.write(`data: ${data}\n\n`);
                },
              }
            );

            allResults.push(...results);
          } catch (error) {
            console.warn(`Ïπ¥ÌÖåÍ≥†Î¶¨ ${categoryNo} ÌÅ¨Î°§ÎßÅ Ïã§Ìå®:`, error);
          }
        }

        // ÏµúÏ¢Ö ÏôÑÎ£å Î©îÏãúÏßÄ (Îã§Ï§ë Ïπ¥ÌÖåÍ≥†Î¶¨)
        const finalData = JSON.stringify({
          type: "complete",
          results: allResults.map((item) => ({
            title: item.title,
            content: item.content,
            url: item.url,
            author: item.siteSpecificData?.author,
            publishDate: item.siteSpecificData?.publishDate,
            viewCount: item.siteSpecificData?.viewCount,
            commentCount: item.siteSpecificData?.commentCount,
            tags: item.siteSpecificData?.tags,
            category: item.siteSpecificData?.category,
            thumbnailUrl: item.siteSpecificData?.thumbnailUrl,
          })),
          totalItems: allResults.length,
        });
        reply.raw.write(`data: ${finalData}\n\n`);
      } else {
        // Îã®Ïùº URL ÌÅ¨Î°§ÎßÅ
        const results = await crawlService.crawlNaverBlog(
          url,
          { maxPages, maxItems },
          {
            onProgress: (progress) => {
              const data = JSON.stringify({
                type: "progress",
                progress,
              });
              reply.raw.write(`data: ${data}\n\n`);
            },
            onItem: (item) => {
              const data = JSON.stringify({
                type: "item",
                item: {
                  title: item.title,
                  content: item.content,
                  url: item.url,
                  author: item.siteSpecificData?.author,
                  publishDate: item.siteSpecificData?.publishDate,
                  viewCount: item.siteSpecificData?.viewCount,
                  commentCount: item.siteSpecificData?.commentCount,
                  tags: item.siteSpecificData?.tags,
                  category: item.siteSpecificData?.category,
                  thumbnailUrl: item.siteSpecificData?.thumbnailUrl,
                },
              });
              reply.raw.write(`data: ${data}\n\n`);
            },
            onError: (error) => {
              const data = JSON.stringify({
                type: "error",
                message: error.message,
              });
              reply.raw.write(`data: ${data}\n\n`);
            },
          }
        );

        // ÏµúÏ¢Ö ÏôÑÎ£å Î©îÏãúÏßÄ
        const finalData = JSON.stringify({
          type: "complete",
          results: results.map((item) => ({
            title: item.title,
            content: item.content,
            url: item.url,
            author: item.siteSpecificData?.author,
            publishDate: item.siteSpecificData?.publishDate,
            viewCount: item.siteSpecificData?.viewCount,
            commentCount: item.siteSpecificData?.commentCount,
            tags: item.siteSpecificData?.tags,
            category: item.siteSpecificData?.category,
            thumbnailUrl: item.siteSpecificData?.thumbnailUrl,
          })),
          totalItems: results.length,
        });
        reply.raw.write(`data: ${finalData}\n\n`);
      }
    } catch (error) {
      const errorData = JSON.stringify({
        type: "error",
        message: error instanceof Error ? error.message : "Unknown error",
      });
      reply.raw.write(`data: ${errorData}\n\n`);
    } finally {
      reply.raw.end();
    }
  }

  @Post("/insights/shopping")
  @Schema({
    description: "Get Naver shopping insights data",
    tags: ["insights"],
    security: [{ bearerAuth: [] }],
    body: {
      type: "object",
      properties: {
        startDate: { type: "string", format: "date" },
        endDate: { type: "string", format: "date" },
        timeUnit: { type: "string", enum: ["date", "week", "month"] },
        category: {
          type: "array",
          items: {
            type: "object",
            properties: {
              name: { type: "string" },
              param: {
                type: "array",
                items: { type: "string" },
              },
            },
            required: ["name", "param"],
          },
        },
        device: { type: "string", enum: ["pc", "mo"] },
        gender: { type: "string", enum: ["m", "f"] },
        ages: {
          type: "array",
          items: { type: "string", enum: ["10", "20", "30", "40", "50", "60"] },
        },
      },
      required: ["startDate", "endDate", "timeUnit"],
    },
  })
  async getShoppingInsights(
    request: FastifyRequest<{ Body: ShoppingInsightsParams }>,
    reply: FastifyReply
  ) {
    try {
      const { startDate, endDate, timeUnit, category, device, gender, ages } =
        request.body;

      // ÎÇ†Ïßú ÌòïÏãù Í≤ÄÏ¶ù
      const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
      if (!dateRegex.test(startDate) || !dateRegex.test(endDate)) {
        return reply.status(400).send({
          error: "ÎÇ†Ïßú ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§. (YYYY-MM-DD ÌòïÏãù ÌïÑÏöî)",
        });
      }

      // ÏãúÏûë ÎÇ†ÏßúÍ∞Ä Ï¢ÖÎ£å ÎÇ†ÏßúÎ≥¥Îã§ Îπ†Î•∏ÏßÄ Í≤ÄÏ¶ù
      if (new Date(startDate) > new Date(endDate)) {
        return reply.status(400).send({
          error: "ÏãúÏûë ÎÇ†ÏßúÎäî Ï¢ÖÎ£å ÎÇ†ÏßúÎ≥¥Îã§ Îπ®ÎùºÏïº Ìï©ÎãàÎã§.",
        });
      }

      const result = await this.naverAPI.getShoppingCategories({
        startDate,
        endDate,
        timeUnit,
        category,
        device,
        gender,
        ages,
      });

      return reply.send(result);
    } catch (error) {
      request.log.error("Shopping insights error:", error);

      // ÎÑ§Ïù¥Î≤Ñ API Ïò§Î•ò Ï≤òÎ¶¨
      if (error instanceof Error) {
        if (error.message.includes("401")) {
          return reply.status(401).send({
            error: "ÎÑ§Ïù¥Î≤Ñ API Ïù∏Ï¶ùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. API ÌÇ§Î•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.",
          });
        }
        if (error.message.includes("429")) {
          return reply.status(429).send({
            error: "API Ìò∏Ï∂ú ÌïúÎèÑÎ•º Ï¥àÍ≥ºÌñàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.",
          });
        }
        if (error.message.includes("400")) {
          return reply.status(400).send({
            error: "ÏûòÎ™ªÎêú ÏöîÏ≤≠ÏûÖÎãàÎã§. ÌååÎùºÎØ∏ÌÑ∞Î•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.",
          });
        }
      }

      return reply.status(500).send({
        error: "ÏáºÌïë Ïù∏ÏÇ¨Ïù¥Ìä∏ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
      });
    }
  }
}
