name: Deploy Dig-Duck to S3, CloudFront and EC2

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      deploy_target:
        description: "배포 대상 선택"
        required: true
        default: "both"
        type: choice
        options:
          - frontend
          - backend
          - both

env:
  DOCKER_IMAGE: cinnamatcha/dig-duck-api
  APP_DIR: /home/cinnamon/dig-duck

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      frontend: ${{ steps.changes.outputs.frontend }}
      backend: ${{ steps.changes.outputs.backend }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect changes
        id: changes
        run: |
          echo "=== 변경된 파일들 ==="
          git diff --name-only HEAD~1 HEAD || echo "초기 커밋"
          echo "===================="

          # Frontend 변경 감지 (dig-duck 앱 + shared packages)
          if git diff --name-only HEAD~1 HEAD | grep -E "^(apps/dig-duck/|packages/)" > /dev/null || [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "frontend=true" >> $GITHUB_OUTPUT
            echo "✅ Frontend 변경 감지"
          else
            echo "frontend=false" >> $GITHUB_OUTPUT
            echo "❌ Frontend 변경 없음"
          fi

          # Backend 변경 감지 (apps/api 폴더 + shared packages)
          if git diff --name-only HEAD~1 HEAD | grep -E "^(apps/api/|packages/)" > /dev/null || [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "backend=true" >> $GITHUB_OUTPUT
            echo "✅ Backend 변경 감지"
          else
            echo "backend=false" >> $GITHUB_OUTPUT
            echo "❌ Backend 변경 없음"
          fi

  deploy-frontend:
    needs: detect-changes
    if: |
      (needs.detect-changes.outputs.frontend == 'true') || 
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.deploy_target == 'frontend' || github.event.inputs.deploy_target == 'both'))
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js and pnpm
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install

      - name: Build Dig-Duck app
        run: pnpm build --filter=dig-duck
        env:
          NODE_ENV: production
          VITE_API_URL: ${{ secrets.VITE_API_URL }}
          VITE_APP_ENV: production
          VITE_LOG_LEVEL: error
          VITE_ENABLE_DEVTOOLS: false

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-northeast-2

      - name: Sync to S3
        run: |
          aws s3 sync apps/dig-duck/dist/ s3://digduck.app --delete --cache-control max-age=60 --exclude "*" --include "*.html"
          aws s3 sync apps/dig-duck/dist/ s3://digduck.app --delete --cache-control max-age=31536000 --exclude "*.html"

      - name: Invalidate CloudFront Cache
        run: |
          if [ -n "${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}" ]; then
            echo "✅ CloudFront Distribution ID 존재, 캐시 무효화 진행"
            aws cloudfront create-invalidation --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} --paths "/*"
            echo "✅ CloudFront 캐시 무효화 완료"
          else
            echo "⚠️ CLOUDFRONT_DISTRIBUTION_ID secret이 설정되지 않음"
            echo "CloudFront 캐시 무효화를 건너뜁니다."
            echo "💡 설정 방법: GitHub Repository Settings > Secrets에서 CLOUDFRONT_DISTRIBUTION_ID 추가"
          fi

      - name: Frontend deployment notification
        run: echo "✅ Frontend 배포 완료! S3 + CloudFront 업데이트됨"

  build-and-deploy:
    needs: detect-changes
    if: |
      (needs.detect-changes.outputs.backend == 'true') ||
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.deploy_target == 'backend' || github.event.inputs.deploy_target == 'both'))
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js and pnpm
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install

      - name: Make Docker Env
        run: |
          cd apps/api
          touch ./.env
          echo "${{ secrets.DOCKER_ENV }}" > ./.env
          echo "✅ GitHub Secrets에서 .env 파일 생성 완료"
          echo "생성된 .env 파일 확인:"
          ls -la .env

      - name: Generate Prisma Client
        run: cd apps/api && pnpm db:generate

      - name: Build API
        run: pnpm build --filter=api

      - name: Build Docker image
        run: |
          # .env 파일이 있는지 확인
          if [ -f "apps/api/.env" ]; then
            echo "✅ .env 파일 존재, Docker 빌드 진행"
            docker build -t dig-duck-api:latest -f apps/api/Dockerfile .
          else
            echo "❌ .env 파일 없음, Docker 빌드 진행"
            docker build -t dig-duck-api:latest -f apps/api/Dockerfile .
          fi

      - name: Login to Docker Registry
        run: |
          echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin

      - name: Tag and push Docker image
        run: |
          docker tag dig-duck-api:latest ${{ env.DOCKER_IMAGE }}:latest
          docker tag dig-duck-api:latest ${{ env.DOCKER_IMAGE }}:${{ github.sha }}
          docker push ${{ env.DOCKER_IMAGE }}:latest
          docker push ${{ env.DOCKER_IMAGE }}:${{ github.sha }}

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: github-actions
          password: ${{ secrets.EC2_PASSWORD }}
          port: 22
          timeout: 300s
          script: |
            set -e

            # 디렉토리로 이동
            cd ${{ env.APP_DIR }}

            echo "=== Blue-Green 배포 시작 ==="
            echo "현재 시간: $(date)"

            # 현재 활성 환경 확인
            CURRENT_ENV=$(grep -o "dig-duck-api-[blue|green]" nginx.conf | head -1 | sed 's/dig-duck-api-//')
            echo "현재 활성 환경: $CURRENT_ENV"

            # 새로운 환경 결정 (현재가 blue면 green으로, green이면 blue로)
            if [ "$CURRENT_ENV" = "blue" ]; then
              NEW_ENV="green"
              OLD_ENV="blue"
              NEW_PORT="8082"
            else
              NEW_ENV="blue"
              OLD_ENV="green"
              NEW_PORT="8081"
            fi

            echo "새로운 환경: $NEW_ENV"
            echo "포트: $NEW_PORT"

            # Docker 이미지 풀
            echo "=== Docker 이미지 풀링 ==="
            docker pull ${{ env.DOCKER_IMAGE }}:latest

            # 환경변수 파일 업데이트 (새로운 이미지 태그로)
            sed -i "s|DOCKER_IMAGE=.*|DOCKER_IMAGE=${{ env.DOCKER_IMAGE }}:${{ github.sha }}|" .env

            # 새로운 환경의 컨테이너 중지 및 재시작
            echo "=== $NEW_ENV 환경 업데이트 ==="
            docker-compose stop dig-duck-api-$NEW_ENV || true
            docker-compose rm -f dig-duck-api-$NEW_ENV || true

            # 새로운 환경 시작
            docker-compose up -d dig-duck-api-$NEW_ENV

            echo "=== $NEW_ENV 환경 헬스체크 대기 ==="
            sleep 30

            # 헬스체크 함수
            health_check() {
              local env=$1
              local max_attempts=30
              local attempt=1
              
              echo "$env 환경 헬스체크 시작..."
              
              while [ $attempt -le $max_attempts ]; do
                echo "헬스체크 시도 $attempt/$max_attempts"
                
                # API 직접 헬스체크
                if curl -f -s --max-time 10 http://localhost:$NEW_PORT/health > /dev/null 2>&1; then
                  echo "✅ $env 환경 헬스체크 성공!"
                  return 0
                fi
                
                echo "❌ 헬스체크 실패, 5초 후 재시도..."
                sleep 5
                attempt=$((attempt + 1))
              done
              
              echo "❌ $env 환경 헬스체크 최종 실패"
              return 1
            }

            # 새로운 환경 헬스체크
            if health_check $NEW_ENV; then
              echo "=== 트래픽 스위칭 ==="
              
              # nginx.conf 백업
              cp nginx.conf nginx.conf.backup
              
              # nginx.conf에서 upstream 변경
              sed -i "s/server dig-duck-api-$OLD_ENV:3000/# server dig-duck-api-$OLD_ENV:3000/" nginx.conf
              sed -i "s/# server dig-duck-api-$NEW_ENV:3000/server dig-duck-api-$NEW_ENV:3000/" nginx.conf
              
              # Docker Nginx 재시작
              docker-compose restart nginx-lb
              
              echo "=== 스위칭 후 최종 헬스체크 ==="
              sleep 10
              
              # 최종 헬스체크
              if curl -f -s --max-time 10 http://localhost:8080/health > /dev/null 2>&1; then
                echo "✅ 배포 성공! $NEW_ENV 환경으로 트래픽 전환 완료"
                
                # 이전 환경 정리 (선택사항)
                echo "=== 이전 환경 정리 ==="
                docker-compose stop dig-duck-api-$OLD_ENV
                
                # 사용하지 않는 이미지 정리
                docker image prune -f
                
                echo "=== 배포 완료 ==="
                echo "활성 환경: $NEW_ENV"
                echo "완료 시간: $(date)"
                
              else
                echo "❌ 스위칭 후 헬스체크 실패! 롤백 수행"
                
                # nginx.conf 복원
                cp nginx.conf.backup nginx.conf
                docker-compose restart nginx-lb
                
                # 새로운 환경 중지
                docker-compose stop dig-duck-api-$NEW_ENV
                
                echo "❌ 롤백 완료. $OLD_ENV 환경으로 복원됨"
                exit 1
              fi
              
            else
              echo "❌ $NEW_ENV 환경 헬스체크 실패! 롤백 수행"
              
              # 새로운 환경 중지
              docker-compose stop dig-duck-api-$NEW_ENV
              
              # 이전 환경이 실행 중인지 확인하고 필요시 시작
              if ! docker-compose ps dig-duck-api-$OLD_ENV | grep -q "Up"; then
                echo "이전 환경 재시작..."
                docker-compose up -d dig-duck-api-$OLD_ENV
              fi
              
              echo "❌ 배포 실패. $OLD_ENV 환경 유지"
              exit 1
            fi

      - name: Notify Slack on Success
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: "🚀 배포 성공! 새로운 버전이 배포되었습니다."
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify Slack on Failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: "❌ 배포 실패! 이전 환경으로 롤백되었습니다."
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  deployment-summary:
    needs: [detect-changes, deploy-frontend, build-and-deploy]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Deployment Summary
        run: |
          echo "# 🚀 Dig-Duck 배포 요약"
          echo ""
          echo "## 변경 감지 결과"
          echo "- 🎨 Frontend: ${{ needs.detect-changes.outputs.frontend }}"
          echo "- 🔧 Backend: ${{ needs.detect-changes.outputs.backend }}"
          echo ""
          echo "## 배포 결과"
          echo "- 🎨 Frontend 배포: ${{ needs.deploy-frontend.result }}"
          echo "- 🔧 Backend 배포: ${{ needs.build-and-deploy.result }}"
          echo ""

          # 배포 실패 체크
          if [ "${{ needs.deploy-frontend.result }}" = "failure" ] || [ "${{ needs.build-and-deploy.result }}" = "failure" ]; then
            echo "❌ 일부 배포가 실패했습니다!"
            echo ""
            if [ "${{ needs.deploy-frontend.result }}" = "failure" ]; then
              echo "🎨 Frontend 배포 실패: S3/CloudFront 배포를 확인하세요."
            fi
            if [ "${{ needs.build-and-deploy.result }}" = "failure" ]; then
              echo "🔧 Backend 배포 실패: EC2/Docker 상태를 확인하세요."
            fi
            exit 1
          else
            echo "✅ 모든 배포가 성공적으로 완료되었습니다!"
            echo ""
            echo "🌐 Frontend: https://digduck.app"
            echo "🔧 Backend: http://${{ secrets.EC2_HOST }}:8080"
            echo "🐘 Database: PostgreSQL 17"
          fi
